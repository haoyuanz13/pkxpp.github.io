---
layout: post
comments: true
categories: c++
---

[TOC]

看到今天版本编译错误，原因是windows和linux的库函数不一样，结果导致了linux找不到函数，编译报错。几个函数还要搜索才能记起来分别在什么环境下使用以及细微的区别，干脆就把搜索的记录记下来做个总结。^_^

# sprintf
* 原型

```
	int sprintf ( char * str, const char * format, ... );
```

* 平台

windows和linux

* 比较

sprintf和printf最大的区别是输出到不同的地方，前者是字符串，后者是终端。windows和linux区别不大，遇见了再补充。

# snprintf
* 原型

```
	int snprintf ( char * s, size_t n, const char * format, ... );
```

说明：最多从源串中拷贝 n － 1 个字符到目标串中，然后再在后面加一个 0 。所以如果目标串的大小为 n的话，将不会溢出。

* 平台

linux

* 比较

> 最值得注意的：snprintf(linux)版本会自动在后面加'/0'，同时复制的长度也包含了'\0'。_snprintf(windows)版本只是简单的复制指定长度的字符，不自动加'\0'，并且长度也不包含'\0'。

看一个例子印象会深刻不少[2]，看源码:

	#include <stdio.h>
	#include <string.h>
	int main()
	{
	    char buf[20];
	    char *pstr = "this is a test string";
	
	    memset(buf, 0, sizeof(buf));
	    snprintf(buf, sizeof(buf)-1, "%s", pstr);
	    printf("buf = %s, strlen(buf) = %d\n", buf, strlen(buf));
	    return 0;
	
	}

结果：


	// linux的snprintf
	buf = this is a test str, strlen(buf) = 18
	
	// windows的_snprintf
	buf = this is a test stri, strlen(buf) = 19


# _snprintf
* 原型

```
	int _snprintf( char *buffer, size_t count, const char *format [, argument] ... );
```

[官网定义](https://msdn.microsoft.com/en-us/library/aa298594(VS.60).aspx)

> _snprintf returns the number of bytes stored in buffer, not counting the terminating null character. If the number of bytes required to store the data exceeds count, then count bytes of data are stored in buffer and a negative value is returned.

总的来说，'\0'他是不管的。如果你很本分，格式化串的长度小于第二个参数count的话，那就在结尾给你填一个结束符'\0'，否则的话自求多福~~。

* 平台
 
windows

* 比较

见snprintf代码例子

# _s安全版本
* 原型

* 平台
* 
windows

# 总结
1. sprintf在windows和linux下面都有，但是；
2. snprinf(linux)和_snprinf(windows)是相对应的，最重要的注意区别是会不会主动增加'\0'，以及copy的长度是否包含'\0'；
3. _s是微软提出来的安全版本，所以只有windows下面才能使用。

# 参考
[1][snprintf函数使用(Windows与Linux版本)](http://blog.csdn.net/michaelrun/article/details/4222163)

[2][snprintf linux 与 windows下差异](http://blog.csdn.net/perddy/article/details/4291756)